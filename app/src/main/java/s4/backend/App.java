/*
 * This source file was generated by the Gradle 'init' task
 */
package s4.backend;


import org.apache.commons.io.IOUtils;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.http.ResponseEntity;
import org.springframework.boot.SpringApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;

import org.json.JSONObject;

import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import s4.backend.data.PhotoData;
import s4.backend.repositories.PhotoDataRepository;


@RestController
@SpringBootApplication
public class App {
    @Autowired 
    private PhotoDataRepository photoDataRepo; 

    private static final Path UPLOAD_DIRECTORY = Paths.get(System.getProperty("user.dir")+"/uploads");
    private static final String IMAGE_TYPE = ".png";

    // TODO: delete
   	@RequestMapping("/")
    public String getGreeting() {
        System.out.print("Hello World!");
        return "Hello World!";
    }

     /**
     * Queries the database for metadata related to all items that fit within the chosen filters 
     * 
     * @param startDateParameter - early bound on data (any data after this is valid), measured in milliseconds since epoch
     * @param lat1Parameter      - bottom left box point latitutde
     * @param lon1Parameter      - bottom left box point longitude
     * @param lat2Parameter      - top right box point latitutde
     * @param lon2Parameter      - top right box point longitude
     * 
     * Note that all 4 of the Lat/Lon Parameters are needed for filtering by the Lat/Lon box. Include all 4 or nothing.
     * 
     * TODO: make the LatLon box a single parameter instead of 4 
     * 
     */
    @GetMapping(value="/getimagesdata")
    public @ResponseBody ResponseEntity<List<PhotoData>> getImagesData(
            @RequestParam("startTime") Optional<Long> startDateParameter,
            @RequestParam("latitude_1") Optional<Double> lat1Parameter,
            @RequestParam("longitude_1") Optional<Double> lon1Parameter,
            @RequestParam("latitude_2") Optional<Double> lat2Parameter,
            @RequestParam("longitude_2") Optional<Double> lon2Parameter,
            @AuthenticationPrincipal Jwt jwt) 
                throws IOException {

        Long startTimeInMilliSinceEpoch = startDateParameter.orElse(null);
        Double lat1 = lat1Parameter.orElse(null);
        Double lon1 = lon1Parameter.orElse(null);
        Double lat2 = lat2Parameter.orElse(null);
        Double lon2 = lon2Parameter.orElse(null);

        List<PhotoData> data = new ArrayList<>();
        String status = "";

        if(lat1 != null && lon1 != null && lat2 != null && lon2 != null){
            //there's a viable box, we can search
            if(startTimeInMilliSinceEpoch != null){
                data = photoDataRepo.findPhotoDataByLatLonBoxAfterDate(lat1, lon1, lat2, lon2, startTimeInMilliSinceEpoch);
                status = "findPhotoDataByLatLonBoxAfterDate";
            }
            else{
                status = "findPhotoDataByLatLonBox";
                data = photoDataRepo.findPhotoDataByLatLonBox(lat1, lon1, lat2, lon2);
            }
        }
        else if (startTimeInMilliSinceEpoch != null) {
            data = photoDataRepo.findPhotoDataAfterDate(startTimeInMilliSinceEpoch);
            status = "findPhotoDataAfterDate";
        }
        else if(lat1 != null || lon1 != null || lat2 != null || lon2 != null){
            //some valid points but not all necessary point. 
            //no valid filters but they tried so return error
            //report error here?
            status = "ERROR: NEED ALL 4 LAT & LON POINTS";
        }
        else{
            data = photoDataRepo.findAll();
            status = "findAll";
        }

        return ResponseEntity
          .ok()
          .header("QueryFunction",status)
          .body(data); 
    }

    /**
     * Queries the database for images related to all items that fit within the chosen filters 
     * 
     * @param startDateParameter - early bound on data (any data after this is valid), measured in milliseconds since epoch
     * @param lat1Parameter      - bottom left box point latitutde
     * @param lon1Parameter      - bottom left box point longitude
     * @param lat2Parameter      - top right box point latitutde
     * @param lon2Parameter      - top right box point longitude
     * @param jwt   - the Json Web Token used during the authentication process
     * 
     * Note that all 4 of the Lat/Lon Parameters are needed for filtering by the Lat/Lon box. Include all 4 or nothing.
     * 
     * TODO: make the LatLon box a single parameter instead of 4 
     * 
     */
    @GetMapping(value="/getimages", produces="application/zip")
    public @ResponseBody ResponseEntity<byte[]> getImages(@RequestParam("startTime") Optional<Long> startDateParameter,
            @RequestParam("latitude_1") Optional<Double> lat1Parameter,
            @RequestParam("longitude_1") Optional<Double> lon1Parameter,
            @RequestParam("latitude_2") Optional<Double> lat2Parameter,
            @RequestParam("longitude_2") Optional<Double> lon2Parameter,
            @AuthenticationPrincipal Jwt jwt) 
            throws IOException {

        List<PhotoData> associatedData = getImagesData(startDateParameter, lat1Parameter, lon1Parameter, lat2Parameter, lon2Parameter, jwt).getBody();
        List<Path> fileNames = new ArrayList<>();
        for (PhotoData p : associatedData){
            String fileName = UPLOAD_DIRECTORY + "//" + Long.toString(p.getId()) +IMAGE_TYPE;
            fileNames.add(Paths.get(fileName));
        }

        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(byteArrayOutputStream);
        ZipOutputStream zos = new ZipOutputStream(bufferedOutputStream);
        
        for (Path path : fileNames){
            File file = new File(path.toString());
            zos.putNextEntry(new ZipEntry(file.getName()));
            FileInputStream fileInputStream = new FileInputStream(file);

            IOUtils.copy(fileInputStream, zos);

            fileInputStream.close();
            zos.closeEntry();
        }

        zos.finish();
        zos.flush();
        IOUtils.closeQuietly(zos);
        IOUtils.closeQuietly(bufferedOutputStream);
        IOUtils.closeQuietly(byteArrayOutputStream);
        
        //TODO: change to stream response: https://www.baeldung.com/spring-boot-requestmapping-serve-zip
        return ResponseEntity
          .ok()
          .header("Content-Disposition", "attachment; filename=\"image_files.zip\"; paths:"+fileNames.toString())
          .body(byteArrayOutputStream.toByteArray());
    }

     /**
     * Upload an image and associated metadata
     * 
     * @param json  - String storing metadata in a json format
     * @param image - image file to be saved to the file system (will be named after the id of uploaded json metadata)
     * @param jwt   - the Json Web Token used during the authentication process
     * 
     * 
     */
    @PostMapping("/upload")
    public @ResponseBody ResponseEntity<String> uploadData(@RequestPart("json") String json, 
                             @RequestPart("image") MultipartFile image, 
                             @AuthenticationPrincipal Jwt jwt) throws Exception {


        // Convert MultipartFile -> String
        String jsonString = new String(json.getBytes(), StandardCharsets.UTF_8);

        String debug = uploadImageAndData(jsonString, image);

        // TODO: currently returns a debug string. need to change, probably to success/fail
        return ResponseEntity.ok().body(debug);                        
    }
 
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }


    private String uploadImageAndData(String jsonString, MultipartFile image) throws IOException
    {
        StringBuilder debug = new StringBuilder();
        JSONObject jsonObj = new JSONObject(jsonString.toString());

        PhotoData data = new PhotoData(jsonObj);

        //saved_entity contains inserted data and its new ID so use that for other insertions
        PhotoData saved_entity = photoDataRepo.save(data);
        String image_name = UPLOAD_DIRECTORY + "//" + Long.toString(saved_entity.getId()) + IMAGE_TYPE;

        Files.write(Paths.get(image_name), image.getBytes());

        List<Path> result;
        try (Stream<Path> paths = Files.walk(UPLOAD_DIRECTORY)) {
            result = paths
                .filter(Files::isRegularFile)
                    .collect(Collectors.toList());
        } 

        // TODO: delete and swap to success/fail when finished with authentication
        debug.append(saved_entity.toString() + " | ");
        debug.append(result.toString() + " | ");
        debug.append(image.getBytes().length + " | ");
        debug.append(Paths.get(image_name).toString() + " | ");

        return debug.toString();
    }
}
