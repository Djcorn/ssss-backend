/*
 * This source file was generated by the Gradle 'init' task
 */
package s4.backend;


import org.apache.commons.io.IOUtils;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.http.ResponseEntity;
import org.springframework.boot.SpringApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestPart;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.oauth2.jwt.Jwt;

import org.json.JSONObject;

import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDate;
import java.time.ZonedDateTime;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import s4.backend.data.PhotoData;
import s4.backend.repositories.PhotoDataRepository;


@RestController
@SpringBootApplication
public class App {
    @Autowired 
    private PhotoDataRepository photoDataRepo; 

    private Path upload_directory = Paths.get(System.getProperty("user.dir")+"/uploads");

    // TODO: delete
   	@RequestMapping("/")
    public String getGreeting() {
        System.out.print("Hello World!");
        return "Hello World!";
    }

    // TODO: add filter parameters: https://www.speakeasy.com/api-design/filtering-responses
    // parameter is a string representing a ZoneDateTime: 2007-12-03T10:15:30+01:00[Europe/Paris] (yyyy-mm-ddThh::mm::ss+zz:zz)
    @GetMapping(value="/getimagesdata")
    public @ResponseBody ResponseEntity<List<PhotoData>> getImagesData(
        /*** 
         * 
         * startDateParameter - early bound on data (any data after this is valid)
         * lat1Parameter      - bottom left box point latitutde
         * lon1Parameter      - bottom left box point longitude
         * lat2Parameter      - top right box point latitutde
         * lon2Parameter      - top right box point longitude
         * 
         * ***/
        @RequestParam("startdate") Optional<String> startDateParameter,
        @RequestParam("latitude_1") Optional<Double> lat1Parameter,
        @RequestParam("longitude_1") Optional<Double> lon1Parameter,
        @RequestParam("latitude_2") Optional<Double> lat2Parameter,
        @RequestParam("longitude_2") Optional<Double> lon2Parameter,
        @AuthenticationPrincipal Jwt jwt) 
            throws IOException {

        String startDateString = startDateParameter.orElse("");
        Double lat1 = lat1Parameter.orElse(null);
        Double lon1 = lon1Parameter.orElse(null);
        Double lat2 = lat2Parameter.orElse(null);
        Double lon2 = lon2Parameter.orElse(null);
        List<PhotoData> data = null;
        ZonedDateTime startDate = null;
        String returnDate = "empty";

        //this throws an error if the string is bad
        //and it is cause '+' still isn't encoding properly!
        String status = "";
        try{
            startDate = ZonedDateTime.parse(startDateString);
            returnDate = startDate.toString();
        }
        catch (Exception e){
            returnDate = e.toString();
        }

        if(lat1 != null && lon1 != null && lat2 != null && lon2 != null){
            //there's a viable box, we can search
            if(startDate != null){
                //data = photoDataRepo.findPhotoDataByLatLonBoxAfterDate(startDate, lat1, lon1, lat2, lon2);
                status = "findPhotoDataByLatLonBoxAfterDate";
            }
            else{
                status = "findPhotoDataByLatLonBox";
                data = photoDataRepo.findPhotoDataByLatLonBox(lat1, lon1, lat2, lon2);
            }
        }
        else if (startDate != null) {
            //data = photoDataRepo.findPhotoDataAfterDate(startDate);
            status = "findPhotoDataAfterDate";
        }
        else if(lat1 != null || lon1 != null || lat2 != null || lon2 != null){
            //some valid points but not all necessary point. 
            //no valid filters but they tried so return error
            //report error here?
            status = "ERROR";
        }
        else{
            data = photoDataRepo.findAll();
            status = "findAll";
        }

        return ResponseEntity
          .ok()
          .header("Query",status)
          .body(data); 
    }

    // TODO: add filter parameters
    @GetMapping(value="/getimages", produces="application/zip")
    public @ResponseBody ResponseEntity<byte[]> getImages(@AuthenticationPrincipal Jwt jwt) 
            throws IOException {

        List<Path> result;
        try (Stream<Path> paths = Files.walk(upload_directory)) {
            result = paths
                .filter(Files::isRegularFile)
                    .collect(Collectors.toList());
        } 

        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(byteArrayOutputStream);
        ZipOutputStream zos = new ZipOutputStream(bufferedOutputStream);
        
        for (Path path : result){
            File file = new File(path.toString());
            zos.putNextEntry(new ZipEntry(file.getName()));
            FileInputStream fileInputStream = new FileInputStream(file);

            IOUtils.copy(fileInputStream, zos);

            fileInputStream.close();
            zos.closeEntry();
        }

        zos.finish();
        zos.flush();
        IOUtils.closeQuietly(zos);
        IOUtils.closeQuietly(bufferedOutputStream);
        IOUtils.closeQuietly(byteArrayOutputStream);
        
        return ResponseEntity
          .ok()
          .header("Content-Disposition", "attachment; filename=\"image_files.zip\"")
          .body(byteArrayOutputStream.toByteArray());
    }

    @PostMapping("/upload")
    public @ResponseBody ResponseEntity<String> uploadData(@RequestPart("json") String json, 
                             @RequestPart("image") MultipartFile image, 
                             @AuthenticationPrincipal Jwt jwt) throws Exception {


        // Convert MultipartFile -> String
        String jsonString = new String(json.getBytes(), StandardCharsets.UTF_8);

        String debug = uploadImageAndData(jsonString, image);

        // TODO: currently returns a debug string. need to change, probably to success/fail
        return ResponseEntity.ok().body(debug);                        
    }
 
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }


    private String uploadImageAndData(String jsonString, MultipartFile image) throws IOException
    {
        StringBuilder debug = new StringBuilder();
        JSONObject jsonObj = new JSONObject(jsonString.toString());

        PhotoData data = new PhotoData(jsonObj);

        //saved_entity contains inserted data and its new ID so use that for other insertions
        PhotoData saved_entity = photoDataRepo.save(data);
        String image_name = upload_directory + "//" + Long.toString(saved_entity.getId()) + ".png";

        Files.write(Paths.get(image_name), image.getBytes());

        List<Path> result;
        try (Stream<Path> paths = Files.walk(upload_directory)) {
            result = paths
                .filter(Files::isRegularFile)
                    .collect(Collectors.toList());
        } 

        // TODO: delete and swap to success/fail when finished with authentication
        debug.append(saved_entity.toString() + " | ");
        debug.append(result.toString() + " | ");
        debug.append(image.getBytes().length + " | ");
        debug.append(Paths.get(image_name).toString() + " | ");

        return debug.toString();
    }
}
